import * as p from '@clack/prompts';
import pc from 'picocolors';
import fs from 'fs-extra';
import path from 'path';
import ora from 'ora';
import { oklch, formatCss, formatHex, wcagContrast, parse } from 'culori';
import {
  BackgroundColor,
  Color,
  Theme,
} from '@adobe/leonardo-contrast-colors';

// ── Types ──

interface OklchColor {
  mode: 'oklch';
  l: number;
  c: number;
  h: number;
  alpha?: number;
}

interface ColorScale {
  [step: string]: string;
}

interface ThemeCreateOptions {
  primary?: string;
  secondary?: string;
  accent?: string;
  neutral?: string;
  name: string;
  output: string;
  wcagLevel: 'AA' | 'AAA';
  format: 'all' | 'tokens' | 'css';
}

// ── Default contrast ratios for scale generation ──

const DEFAULT_CONTRAST_RATIOS: Record<string, number> = {
  '50': 1.05,
  '100': 1.15,
  '200': 1.3,
  '300': 1.6,
  '400': 2.5,
  '500': 4.5,
  '600': 7.0,
  '700': 10.0,
  '800': 13.0,
  '900': 15.0,
  '950': 18.0,
};

// ── Color conversion utilities ──

function hexToOklch(hex: string): OklchColor {
  const parsed = oklch(hex);
  if (!parsed) {
    throw new Error(`Invalid color: ${hex}`);
  }
  return {
    mode: 'oklch',
    l: parsed.l ?? 0,
    c: parsed.c ?? 0,
    h: parsed.h ?? 0,
    alpha: parsed.alpha,
  };
}

function oklchToHex(color: OklchColor): string {
  return formatHex(color) ?? '#000000';
}

function formatOklchCss(color: OklchColor): string {
  return formatCss(color) ?? `oklch(${color.l} ${color.c} ${color.h})`;
}

function adjustLightness(color: OklchColor, lightness: number): OklchColor {
  return {
    ...color,
    l: Math.max(0, Math.min(1, lightness)),
  };
}

// ── Scale generation using Leonardo ──

function generateScale(
  name: string,
  baseColor: OklchColor
): ColorScale {
  const background: OklchColor = {
    mode: 'oklch',
    l: 0.99,
    c: 0.01,
    h: baseColor.h,
  };

  const bgColor = new BackgroundColor({
    name: 'background',
    colorKeys: [oklchToHex(background)],
    ratios: [1],
  });

  const leonardoColor = new Color({
    name,
    colorKeys: [oklchToHex(baseColor)],
    ratios: DEFAULT_CONTRAST_RATIOS,
    smooth: true,
  });

  const theme = new Theme({
    colors: [leonardoColor],
    backgroundColor: bgColor,
    lightness: Math.round(background.l * 100),
    output: 'HEX',
  });

  const pairs = theme.contrastColorPairs as Record<string, string>;

  // Build scale — use Leonardo output with OKLCH fallbacks
  const scale: ColorScale = {};
  const steps = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950'];
  const fallbackLightness = [0.95, 0.90, 0.85, 0.75, 0.65, 0.55, 0.45, 0.35, 0.25, 0.15, 0.10];

  steps.forEach((step, i) => {
    if (pairs[step]) {
      // Convert Leonardo's hex output back to OKLCH for consistent output
      const asOklch = hexToOklch(pairs[step]);
      scale[step] = formatOklchCss(asOklch);
    } else {
      scale[step] = formatOklchCss(adjustLightness(baseColor, fallbackLightness[i]));
    }
  });

  return scale;
}

// ── Contrast validation ──

interface ValidationResult {
  valid: boolean;
  issues: string[];
  details: Array<{
    shade: string;
    ratio: number;
    passes: boolean;
  }>;
}

function validateScale(
  scale: ColorScale,
  wcagLevel: 'AA' | 'AAA'
): ValidationResult {
  const targetRatio = wcagLevel === 'AAA' ? 7.0 : 4.5;
  const issues: string[] = [];
  const details: ValidationResult['details'] = [];

  // White background for contrast checks
  const whiteBg = parse('oklch(0.99 0.01 250)');

  // Check text-eligible shades (600+)
  const textShades = ['600', '700', '800', '900', '950'];

  for (const shade of textShades) {
    const color = parse(scale[shade]);
    if (!color || !whiteBg) continue;

    const ratio = wcagContrast(color, whiteBg);

    const passes = ratio >= targetRatio;
    details.push({ shade, ratio, passes });

    if (!passes) {
      issues.push(
        `Shade ${shade}: ${ratio.toFixed(2)}:1 contrast (needs ${targetRatio}:1 for ${wcagLevel})`
      );
    }
  }

  return { valid: issues.length === 0, issues, details };
}

// ── Output generators ──

function generateDtcgTokens(
  themeName: string,
  scales: Record<string, ColorScale>
): Record<string, unknown> {
  const tokens: Record<string, unknown> = {
    $description: `Theme "${themeName}" — generated by js-ds-ui theme:create. WCAG 2.2 AAA contrast-safe.`,
    color: {
      $type: 'color',
    },
  };

  const colorNode = tokens.color as Record<string, unknown>;

  for (const [role, scale] of Object.entries(scales)) {
    const roleNode: Record<string, unknown> = {};

    for (const [step, value] of Object.entries(scale)) {
      roleNode[step] = {
        $value: value,
        $description: `${role} ${step}`,
      };
    }

    colorNode[role] = roleNode;
  }

  // Add semantic mappings
  colorNode['text'] = {
    $type: 'color',
    primary: {
      $value: '{color.neutral.900}',
      $description: 'Primary text color',
    },
    secondary: {
      $value: '{color.neutral.700}',
      $description: 'Secondary text color',
    },
    inverse: {
      $value: '{color.neutral.50}',
      $description: 'Text on dark backgrounds',
    },
  };

  colorNode['background'] = {
    $type: 'color',
    primary: {
      $value: '{color.neutral.50}',
      $description: 'Primary background',
    },
    secondary: {
      $value: '{color.neutral.100}',
      $description: 'Secondary background',
    },
  };

  colorNode['interactive'] = {
    $type: 'color',
    primary: {
      $value: '{color.primary.500}',
      $description: 'Primary interactive color',
    },
    'primary-hover': {
      $value: '{color.primary.600}',
      $description: 'Primary interactive hover',
    },
    'primary-active': {
      $value: '{color.primary.700}',
      $description: 'Primary interactive active',
    },
  };

  colorNode['border'] = {
    $type: 'color',
    default: {
      $value: '{color.neutral.200}',
      $description: 'Default border',
    },
    hover: {
      $value: '{color.neutral.300}',
      $description: 'Border on hover',
    },
    focus: {
      $value: '{color.primary.500}',
      $description: 'Border on focus',
    },
  };

  return tokens;
}

function generateCss(
  themeName: string,
  scales: Record<string, ColorScale>
): string {
  const lines: string[] = [
    `/* Theme: ${themeName} — generated by js-ds-ui theme:create */`,
    '',
    ':root,',
    `[data-theme="${themeName}"] {`,
  ];

  for (const [role, scale] of Object.entries(scales)) {
    lines.push(`  /* ${role} */`);
    for (const [step, value] of Object.entries(scale)) {
      lines.push(`  --color-${role}-${step}: ${value};`);
    }
    lines.push('');
  }

  // Semantic aliases
  lines.push('  /* Semantic aliases */');
  lines.push('  --color-text-primary: var(--color-neutral-900);');
  lines.push('  --color-text-secondary: var(--color-neutral-700);');
  lines.push('  --color-text-inverse: var(--color-neutral-50);');
  lines.push('  --color-background-primary: var(--color-neutral-50);');
  lines.push('  --color-background-secondary: var(--color-neutral-100);');
  lines.push('  --color-interactive-primary: var(--color-primary-500);');
  lines.push('  --color-interactive-primary-hover: var(--color-primary-600);');
  lines.push('  --color-interactive-primary-active: var(--color-primary-700);');
  lines.push('  --color-border-default: var(--color-neutral-200);');
  lines.push('  --color-border-hover: var(--color-neutral-300);');
  lines.push('  --color-border-focus: var(--color-primary-500);');

  lines.push('}');
  lines.push('');

  // Dark theme variant (auto-generated inverted scale)
  lines.push(`[data-theme="${themeName}-dark"] {`);
  for (const [role, scale] of Object.entries(scales)) {
    lines.push(`  /* ${role} (dark) */`);
    const steps = Object.keys(scale);
    const reversedSteps = [...steps].reverse();
    steps.forEach((step, i) => {
      lines.push(`  --color-${role}-${step}: ${scale[reversedSteps[i]]};`);
    });
    lines.push('');
  }
  lines.push('  /* Semantic aliases (dark) */');
  lines.push('  --color-text-primary: var(--color-neutral-50);');
  lines.push('  --color-text-secondary: var(--color-neutral-200);');
  lines.push('  --color-text-inverse: var(--color-neutral-900);');
  lines.push('  --color-background-primary: var(--color-neutral-950);');
  lines.push('  --color-background-secondary: var(--color-neutral-900);');
  lines.push('  --color-interactive-primary: var(--color-primary-400);');
  lines.push('  --color-interactive-primary-hover: var(--color-primary-300);');
  lines.push('  --color-interactive-primary-active: var(--color-primary-200);');
  lines.push('  --color-border-default: var(--color-neutral-700);');
  lines.push('  --color-border-hover: var(--color-neutral-600);');
  lines.push('  --color-border-focus: var(--color-primary-400);');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ── Main command ──

export async function themeCreateCommand(options: Record<string, string | undefined>) {
  console.log('');
  p.intro(pc.bgMagenta(pc.white(' js-ds-ui theme:create ')));

  // Resolve options — prompt for missing values
  const resolvedOptions = await resolveOptions(options);

  if (!resolvedOptions) {
    p.cancel('Operation cancelled.');
    process.exit(0);
  }

  const spinner = ora('Generating theme...').start();

  try {
    // Convert input colors to OKLCH
    const colorInputs: Record<string, OklchColor> = {};

    spinner.text = 'Converting colors to OKLCH...';

    if (resolvedOptions.primary) {
      colorInputs.primary = hexToOklch(resolvedOptions.primary);
    }

    if (resolvedOptions.secondary) {
      colorInputs.secondary = hexToOklch(resolvedOptions.secondary);
    } else if (resolvedOptions.primary) {
      // Auto-derive secondary by shifting hue +120 degrees
      const base = colorInputs.primary;
      colorInputs.secondary = {
        mode: 'oklch',
        l: base.l + 0.05,
        c: base.c * 0.85,
        h: (base.h + 120) % 360,
      };
    }

    if (resolvedOptions.accent) {
      colorInputs.accent = hexToOklch(resolvedOptions.accent);
    } else if (resolvedOptions.primary) {
      // Auto-derive accent by shifting hue -110 degrees
      const base = colorInputs.primary;
      colorInputs.accent = {
        mode: 'oklch',
        l: base.l + 0.10,
        c: base.c * 0.90,
        h: (base.h + 250) % 360,
      };
    }

    if (resolvedOptions.neutral) {
      colorInputs.neutral = hexToOklch(resolvedOptions.neutral);
    } else if (resolvedOptions.primary) {
      // Auto-derive neutral from primary hue with very low chroma
      const base = colorInputs.primary;
      colorInputs.neutral = {
        mode: 'oklch',
        l: 0.55,
        c: 0.02,
        h: base.h,
      };
    }

    // Generate scales
    spinner.text = 'Generating color scales with Leonardo...';

    const scales: Record<string, ColorScale> = {};
    for (const [role, color] of Object.entries(colorInputs)) {
      scales[role] = generateScale(role, color);
    }

    // Validate contrast
    spinner.text = 'Validating contrast ratios...';

    const validations: Record<string, ValidationResult> = {};
    let allValid = true;

    for (const [role, scale] of Object.entries(scales)) {
      const result = validateScale(scale, resolvedOptions.wcagLevel);
      validations[role] = result;
      if (!result.valid) allValid = false;
    }

    spinner.stop();

    // Display results
    console.log('');
    p.log.info(pc.bold('Color Scales Generated'));
    console.log('');

    for (const [role, scale] of Object.entries(scales)) {
      const validation = validations[role];
      const status = validation.valid ? pc.green('PASS') : pc.red('FAIL');
      console.log(`  ${pc.bold(role)} [${status}]`);

      // Show scale preview (compact)
      const steps = ['50', '200', '500', '700', '950'];
      const preview = steps
        .map((step) => {
          const hex = formatHex(parse(scale[step]) ?? { mode: 'rgb', r: 0, g: 0, b: 0 });
          return `${step}:${hex}`;
        })
        .join('  ');
      console.log(`    ${pc.dim(preview)}`);

      if (!validation.valid) {
        for (const issue of validation.issues) {
          console.log(`    ${pc.yellow('!')} ${issue}`);
        }
      }
      console.log('');
    }

    // Show contrast details for text shades
    console.log(pc.bold('  Contrast Ratios (vs white background):'));
    for (const [role, validation] of Object.entries(validations)) {
      for (const detail of validation.details) {
        const icon = detail.passes ? pc.green('*') : pc.red('x');
        const ratioStr = detail.ratio.toFixed(2);
        console.log(
          `    ${icon} ${role}-${detail.shade}: ${ratioStr}:1 ${
            detail.passes ? '' : pc.red(`(needs ${resolvedOptions.wcagLevel === 'AAA' ? '7.0' : '4.5'}:1)`)
          }`
        );
      }
    }
    console.log('');

    // Generate output files
    const outputDir = path.resolve(resolvedOptions.output);
    await fs.ensureDir(outputDir);

    const { format, name: themeName } = resolvedOptions;

    if (format === 'all' || format === 'tokens') {
      const tokens = generateDtcgTokens(themeName, scales);
      const tokensPath = path.join(outputDir, `${themeName}-tokens.json`);
      await fs.writeJSON(tokensPath, tokens, { spaces: 2 });
      p.log.success(`Tokens: ${pc.cyan(tokensPath)}`);
    }

    if (format === 'all' || format === 'css') {
      const css = generateCss(themeName, scales);
      const cssPath = path.join(outputDir, `${themeName}-theme.css`);
      await fs.writeFile(cssPath, css);
      p.log.success(`CSS: ${pc.cyan(cssPath)}`);
    }

    // Summary
    console.log('');
    if (allValid) {
      p.outro(
        pc.green(`Theme "${themeName}" generated successfully — all contrast checks passed!`)
      );
    } else {
      p.outro(
        pc.yellow(
          `Theme "${themeName}" generated with contrast warnings. Review and adjust as needed.`
        )
      );
    }
  } catch (error) {
    spinner.fail('Failed to generate theme');
    if (error instanceof Error) {
      p.log.error(error.message);
    } else {
      p.log.error(String(error));
    }
    process.exit(1);
  }
}

async function resolveOptions(
  cliOptions: Record<string, string | undefined>
): Promise<ThemeCreateOptions | null> {
  let primary = cliOptions.primary;
  let secondary = cliOptions.secondary;
  let accent = cliOptions.accent;
  let neutral = cliOptions.neutral;
  let name = cliOptions.name || 'custom';
  const output = cliOptions.output || './theme-output';
  const wcagLevel = (cliOptions.wcagLevel as 'AA' | 'AAA') || 'AAA';
  const format = (cliOptions.format as 'all' | 'tokens' | 'css') || 'all';

  // If no primary color provided, prompt interactively
  if (!primary) {
    const result = await p.text({
      message: 'Enter your primary brand color (hex)',
      placeholder: '#3b82f6',
      validate: (val) => {
        if (!val) return 'Color is required';
        try {
          hexToOklch(val);
        } catch {
          return 'Invalid color. Use hex format (e.g., #3b82f6)';
        }
      },
    });

    if (p.isCancel(result)) return null;
    primary = result as string;

    // Optionally prompt for secondary
    const wantsSecondary = await p.confirm({
      message: 'Provide a secondary color? (otherwise auto-derived from primary)',
      initialValue: false,
    });

    if (p.isCancel(wantsSecondary)) return null;

    if (wantsSecondary) {
      const secResult = await p.text({
        message: 'Enter secondary color (hex)',
        placeholder: '#8b5cf6',
        validate: (val) => {
          if (!val) return 'Color is required';
          try {
            hexToOklch(val);
          } catch {
            return 'Invalid color. Use hex format (e.g., #8b5cf6)';
          }
        },
      });

      if (p.isCancel(secResult)) return null;
      secondary = secResult as string;
    }

    // Theme name
    const nameResult = await p.text({
      message: 'Theme name',
      placeholder: 'custom',
      defaultValue: 'custom',
    });

    if (p.isCancel(nameResult)) return null;
    name = nameResult as string;
  }

  return {
    primary,
    secondary,
    accent,
    neutral,
    name,
    output,
    wcagLevel,
    format,
  };
}
