#!/usr/bin/env node
/**
 * gen-cli-templates.mjs
 * Reads actual component/hook/util source files and generates
 * packages/cli/src/templates/generated.ts with template functions.
 *
 * This replaces the hand-maintained 12k-line templates/index.ts with
 * an auto-generated version that stays in sync with the source.
 *
 * Run: node scripts/gen-cli-templates.mjs
 */
import { readFileSync, writeFileSync, readdirSync, existsSync } from "node:fs";
import { resolve, dirname, basename } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const COMPONENTS_DIR = resolve(__dirname, "../packages/components/src/ui");
const HOOKS_DIR = resolve(__dirname, "../packages/components/src/hooks");
const LIB_DIR = resolve(__dirname, "../packages/components/src/lib");
const OUT = resolve(__dirname, "../packages/cli/src/templates/generated.ts");

// ── Source file mapping ────────────────────────────────────────────
// Maps template name → { path, type }
function discoverSources() {
  const sources = {};

  // Utils
  const utilsPath = resolve(LIB_DIR, "utils.ts");
  if (existsSync(utilsPath)) {
    sources["utils"] = { path: utilsPath, type: "util" };
  }

  // Hooks
  if (existsSync(HOOKS_DIR)) {
    for (const file of readdirSync(HOOKS_DIR)) {
      if (!file.endsWith(".ts") && !file.endsWith(".tsx")) continue;
      if (file.endsWith(".test.ts") || file.endsWith(".test.tsx")) continue;
      if (file === "index.ts") continue;
      const name = file.replace(/\.tsx?$/, "");
      sources[name] = { path: resolve(HOOKS_DIR, file), type: "hook" };
    }
  }

  // UI components
  if (existsSync(COMPONENTS_DIR)) {
    for (const file of readdirSync(COMPONENTS_DIR)) {
      if (!file.endsWith(".tsx")) continue;
      if (file.endsWith(".test.tsx") || file.endsWith(".stories.tsx") || file.endsWith(".figma.tsx")) continue;
      const name = file.replace(/\.tsx$/, "");
      sources[name] = { path: resolve(COMPONENTS_DIR, file), type: "component" };
    }
  }

  return sources;
}

// ── Strip TypeScript for JS output ─────────────────────────────────
function stripTypeScript(source) {
  return source
    // Remove type imports: import type { ... } from '...'
    .replace(/^import\s+type\s+\{[^}]*\}\s+from\s+['"][^'"]+['"];?\s*$/gm, "")
    // Remove type-only imports from mixed imports: import { type Foo, Bar }
    .replace(/,?\s*type\s+\w+/g, (match, offset, str) => {
      // Only strip if inside an import statement
      const lineStart = str.lastIndexOf("\n", offset) + 1;
      const line = str.slice(lineStart, str.indexOf("\n", offset));
      return line.trimStart().startsWith("import") ? "" : match;
    })
    // Remove interface/type declarations
    .replace(/^export\s+(?:interface|type)\s+\w+[\s\S]*?^\}/gm, "")
    // Remove inline type annotations: : Type
    .replace(/:\s*(?:React\.[\w<>,\s|]+|[\w<>,\s|]+(?:\[\])?)\s*(?=[,)=\{])/g, "")
    // Remove generic type params: <Type>
    .replace(/<(?:React\.[\w<>,\s|]+|[\w<>,\s|]+)>/g, "")
    // Remove as Type casts
    .replace(/\s+as\s+\w+[\w.<>,\s|]*/g, "")
    // Clean up empty lines
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}

// ── Escape template string ─────────────────────────────────────────
function escapeForTemplate(str) {
  return str.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
}

// ── Generate ───────────────────────────────────────────────────────
const sources = discoverSources();
const templateNames = Object.keys(sources).sort();

let output = `/**
 * AUTO-GENERATED by scripts/gen-cli-templates.mjs
 * Do not edit manually — run \`node scripts/gen-cli-templates.mjs\` to regenerate.
 */

`;

// Generate a map of template name → { ts: string, js: string }
output += `const TEMPLATES: Record<string, { ts: string; js: string }> = {\n`;

for (const name of templateNames) {
  const { path: srcPath } = sources[name];
  const tsSource = readFileSync(srcPath, "utf-8");
  const jsSource = stripTypeScript(tsSource);

  output += `  '${name}': {\n`;
  output += `    ts: \`${escapeForTemplate(tsSource)}\`,\n`;
  output += `    js: \`${escapeForTemplate(jsSource)}\`,\n`;
  output += `  },\n`;
}

output += `};\n\n`;

// Generate the lookup function
output += `/**
 * Get a component template by name.
 * @param name - Component/hook/util name
 * @param typescript - Whether to return TypeScript or JavaScript
 * @returns The template source string, or empty string if not found
 */
export function getComponentTemplate(name: string, typescript: boolean): string {
  const entry = TEMPLATES[name];
  if (!entry) return '';
  return typescript ? entry.ts : entry.js;
}

export function getAvailableTemplates(): string[] {
  return Object.keys(TEMPLATES);
}
`;

writeFileSync(OUT, output);
console.log(`Generated ${templateNames.length} templates to ${OUT}`);
